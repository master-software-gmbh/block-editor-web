var V = Object.defineProperty;
var Z = (n, t, e) => t in n ? V(n, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : n[t] = e;
var v = (n, t, e) => Z(n, typeof t != "symbol" ? t + "" : t, e);
import { n as C, D as J, i as F, t as B, _ as O, f as w, b as m, e as y, m as H, p as E, L as Y, r as k, j as G, d as T, q as U, R as Q, B as tt, a as et, T as nt, F as ot, l as _, c as N, k as q, g as L, h as it } from "./main-D94eW5XA.js";
function st(n) {
  return Object.keys(n).map((t) => {
    let e = n[t];
    if (e == null)
      return `${t}=`;
    if (typeof e == "object" ? e = JSON.stringify(e) : e = e.toString(), typeof e == "string") {
      const i = e.includes(" ") || e.includes("="), o = e.includes('"') || e.includes("\\");
      o && (e = e.replace(/["\\]/g, "\\$&")), (i || o) && (e = `"${e}"`);
    }
    return `${t}=${e}`;
  }).join(" ");
}
class rt {
  constructor(t) {
    this.format = t;
  }
  debug(t, e = {}) {
    console.debug(this._serialize(t, "debug", e));
  }
  info(t, e = {}) {
    console.info(this._serialize(t, "info", e));
  }
  warn(t, e = {}) {
    console.warn(this._serialize(t, "warn", e));
  }
  error(t, e = {}) {
    console.error(this._serialize(t, "error", e));
  }
  _serialize(t, e, i = {}) {
    const o = this._data(t, e, i);
    switch (this.format) {
      case "json":
        try {
          return JSON.stringify(o);
        } catch {
          return String(o);
        }
      case "logfmt":
        return st(o);
    }
  }
  _data(t, e, i = {}) {
    const { message: o, level: s, error: r, ...a } = i, l = {
      level: e,
      message: t,
      data_level: s,
      data_message: o,
      ...a
    };
    return r && r instanceof Error && (l.error = {
      name: r.name,
      stack: r.stack,
      message: r.message
    }), l;
  }
}
const h = new rt("json");
async function K(n, t) {
  const e = Date.now(), [i] = await Promise.all([n(), new Promise((s) => setTimeout(s, t))]), o = Date.now() - e;
  return o > t + 5 && h.warn("Constant-time operation took longer than expected", {
    duration_ms: o,
    min_duration_ms: t
  }), i;
}
function W(n, t) {
  let e;
  return (...i) => {
    window.clearTimeout(e), e = window.setTimeout(() => {
      n(...i);
    }, t);
  };
}
function D(n) {
  return {
    get(t) {
      return t[n];
    },
    set(t, e) {
      return { ...t, [n]: e };
    }
  };
}
function A(n, t) {
  return n.get(t);
}
function M(n, t, e) {
  return n.set(t, e);
}
function z(n, t) {
  return {
    get(e) {
      return A(t, A(n, e));
    },
    set(e, i) {
      return M(n, e, M(t, A(n, e), i));
    }
  };
}
function lt(n) {
  return {
    get(t) {
      const e = typeof n == "function" ? n(t) : n;
      return t[e];
    },
    set(t, e) {
      const i = typeof n == "function" ? n(t) : n;
      return t.map((o, s) => s === i ? e : o);
    }
  };
}
function at(n) {
  return lt((t) => t.findIndex((e) => e.id === n));
}
function P(n, t) {
  for (const [e, i] of Object.entries(n))
    if (!(typeof i == "boolean" && !i && !(e in t)) && (!(e in t) || i !== t[e]))
      return !1;
  return !0;
}
class $ {
  constructor(t, e) {
    v(this, "document");
    v(this, "selection");
    this.document = t, this.selection = e;
  }
}
h.format = "logfmt";
let dt = class {
  constructor(t) {
    v(this, "uuidFactory");
    this.uuidFactory = t ?? crypto.randomUUID.bind(crypto);
  }
  applyAction(t, e) {
    var i, o;
    switch (e.type) {
      case "insert_text": {
        const s = e.text.split(`

`);
        let r = t;
        for (const [a, l] of s.entries())
          r = this.replaceText(r, l), a < s.length - 1 && (r = this.replaceText(r, `
`));
        return r;
      }
      case "delete_text": {
        if (t.selection.length === 1) {
          const s = t.selection[0];
          if (s.startOffset === s.endOffset) {
            if (s.startOffset > 0)
              s.startOffset -= 1, console.log("Deleting previous character");
            else if (s.type === "rich_text") {
              const r = t.document.children.findIndex((l) => l.id === s.blockId), a = t.document.children.slice(0, r).reverse().find((l) => l.type === "rich-text");
              (a == null ? void 0 : a.type) === "rich-text" && t.selection.unshift({
                type: "rich_text",
                blockId: a.id,
                spanIndex: a.content.spans.length - 1,
                startOffset: ((i = a.content.spans.at(-1)) == null ? void 0 : i.text.length) ?? 0,
                endOffset: ((o = a.content.spans.at(-1)) == null ? void 0 : o.text.length) ?? 0
              });
            }
          }
        }
        return this.replaceText(t, "");
      }
      case "set_attribute":
        return this.applyAttributes(t, { [e.name]: e.value });
      case "toggle_attribute": {
        const r = !!!this.getRangeAttribute(t, e.name);
        return this.applyAttributes(t, { [e.name]: r });
      }
      case "move_block":
        return this.moveBlock(t, e.id, e.index);
      case "remove_block":
        return this.removeBlock(t, e.id);
      case "insert_paragraph":
        return this.replaceText(t, `
`);
      default:
        return t;
    }
  }
  getRangeAttribute(t, e) {
    for (const i of t.selection) {
      if (i.type !== "rich_text")
        continue;
      const o = this.getBlockById(t.document, i.blockId);
      if ((o == null ? void 0 : o.type) === "rich-text") {
        const s = o.content.spans.at(i.spanIndex);
        if (!(s != null && s.attributes[e]))
          return !1;
      }
    }
    return !0;
  }
  moveBlock(t, e, i) {
    const o = this.getBlockById(t.document, e);
    if (o) {
      const s = t.document.children.indexOf(o);
      s > -1 && (s < i && (i -= 1), h.debug(`Moving block ${e} from ${s} to ${i}`), t.document.children.splice(s, 1), t.document.children.splice(i, 0, o));
    }
    return t;
  }
  removeBlock(t, e) {
    const i = t.document.children.findIndex((o) => o.id === e);
    return i > -1 && t.document.children.splice(i, 1), t;
  }
  getBlockById(t, e) {
    return t.children.find((i) => i.id === e);
  }
  applyAttributes(t, e) {
    const i = [], o = t.document;
    for (const s of o.children) {
      if (s.type !== "rich-text")
        continue;
      const r = [];
      for (const [a, l] of s.content.spans.entries()) {
        const f = t.selection.find(
          (p) => p.type === "rich_text" && p.blockId === s.id && p.spanIndex === a
        );
        if ((f == null ? void 0 : f.type) !== "rich_text") {
          r.push(l);
          continue;
        }
        const { after: c, before: d, inside: x } = this.splitSpan(l, f);
        d.length && r.push({
          ...l,
          text: d
        }), x.length && (i.push({
          type: "rich_text",
          blockId: s.id,
          spanIndex: r.length,
          startOffset: 0,
          endOffset: x.length
        }), r.push({
          ...l,
          text: x,
          attributes: {
            ...l.attributes,
            ...e
          }
        })), c.length && r.push({
          ...l,
          text: c
        });
      }
      s.content.spans = r;
    }
    return new $(o, i);
  }
  splitSpan(t, e) {
    const i = t.text.slice(0, e.startOffset), o = t.text.slice(e.startOffset, e.endOffset), s = t.text.slice(e.endOffset ?? e.startOffset);
    return {
      before: i,
      inside: o,
      after: s
    };
  }
  expandRange(t, e) {
    const i = e.at(0), o = e.at(1);
    if ((i == null ? void 0 : i.type) !== "rich_text" || (o == null ? void 0 : o.type) !== "rich_text")
      return e;
    const s = [], r = t.children.findIndex((f) => f.id === i.blockId), a = t.children.findIndex((f) => f.id === o.blockId), l = t.children.slice(r, a + 1);
    for (const f of l)
      if (f.type === "rich-text") {
        for (const [c, d] of f.content.spans.entries())
          if (!(f.id === i.blockId && c < i.spanIndex)) {
            if (f.id === i.blockId && c === i.spanIndex) {
              s.push(i);
              continue;
            }
            if (!(f.id === o.blockId && c > o.spanIndex)) {
              if (f.id === o.blockId && c === o.spanIndex) {
                s.push(o);
                continue;
              }
              s.push({
                type: "rich_text",
                blockId: f.id,
                spanIndex: c,
                startOffset: 0,
                endOffset: d.text.length
              });
            }
          }
      }
    return s;
  }
  createEmptyRichTextBlock(t) {
    const e = this.uuidFactory();
    return {
      children: [],
      id: e,
      type: "rich-text",
      content: {
        spans: [
          {
            text: "",
            attributes: t
          }
        ]
      }
    };
  }
  replaceText(t, e) {
    h.info(`Replacing text with "${e}"`);
    const i = [];
    let o = [];
    const s = t.selection.at(0);
    if ((s == null ? void 0 : s.type) === "rich_text")
      o = [
        {
          type: "rich_text",
          blockId: s.blockId,
          spanIndex: s.spanIndex,
          startOffset: s.startOffset + e.length
        }
      ];
    else if ((s == null ? void 0 : s.type) === "plain_text") {
      const c = e.replace(/\n/g, "");
      o = [
        {
          type: "plain_text",
          blockId: s.blockId,
          property: s.property,
          startOffset: s.startOffset + c.length,
          endOffset: s.startOffset + c.length
        }
      ];
    }
    let r = e;
    const a = (c) => {
      const d = JSON.parse(JSON.stringify(c));
      return d.content.spans = [], d;
    };
    let l;
    for (const c of t.selection)
      if (c.type === "title")
        if (e === `
`) {
          const d = this.createEmptyRichTextBlock({});
          o = [
            {
              blockId: d.id,
              spanIndex: 0,
              startOffset: 0,
              type: "rich_text"
            }
          ], r = "", i.push(d);
        } else {
          const d = e.replace(/\n/g, "");
          t.document.content.title = t.document.content.title.slice(0, c.startOffset) + d + t.document.content.title.slice(c.endOffset);
          const x = c.startOffset + d.length, p = c.startOffset + d.length;
          o = [
            {
              type: "title",
              startOffset: x,
              endOffset: p
            }
          ];
        }
    for (const c of t.document.children) {
      l || (l = a(c));
      let d = !1, x = !1;
      if (c.type === "rich-text")
        for (const [p, g] of c.content.spans.entries()) {
          const u = t.selection.findIndex(
            (I) => I.type === "rich_text" && I.blockId === c.id && I.spanIndex === p
          ), S = u === -1 ? void 0 : t.selection.at(u);
          if ((S == null ? void 0 : S.type) !== "rich_text")
            l.content.spans.push(g);
          else {
            x = !0, u === t.selection.length - 1 && (d = !0);
            const { before: I, after: X } = this.splitSpan(g, S);
            l.content.spans.push({
              text: I,
              attributes: g.attributes
            }), r === `
` && (i.push(l), l = this.createEmptyRichTextBlock(g.attributes), o = [
              {
                blockId: l.id,
                spanIndex: 0,
                startOffset: 0,
                type: "rich_text"
              }
            ], r = ""), l.content.spans.push({
              text: r + X,
              attributes: g.attributes
            }), r = "";
          }
        }
      else {
        const p = t.selection.find(
          (g) => g.type === "plain_text" && g.blockId === (l == null ? void 0 : l.id)
        );
        if ((p == null ? void 0 : p.type) === "plain_text" && p.property in l.content) {
          const g = l.content[p.property], u = r.replace(/\n/g, "");
          l.content[p.property] = g.slice(0, p.startOffset) + u + g.slice(p.endOffset);
        }
      }
      (d || !x) && (i.push(l), l = void 0);
    }
    l && i.push(l);
    const f = this.optimizeDocument(R.set(t.document, i), o);
    return new $(f, o);
  }
  optimizeDocument(t, e) {
    let i = t;
    for (const o of t.children)
      o.type === "rich-text" && (i = z(R, at(o.id)).set(
        i,
        this.optimizeRichTextBlock(o, e)
      ));
    return i = R.set(
      i,
      i.children.filter((o) => !(o.type === "rich-text" && o.content.spans.length === 0))
    ), i;
  }
  optimizeRichTextBlock(t, e) {
    var o;
    const i = [];
    for (const [s, r] of t.content.spans.entries()) {
      const a = i.at(i.length - 1);
      if (r.text.length === 0) {
        const l = e.at(0);
        (l == null ? void 0 : l.type) === "rich_text" && l.blockId === t.id && l.spanIndex === s && s > 0 && (l.spanIndex = s - 1, l.startOffset = ((o = i.at(-1)) == null ? void 0 : o.text.length) ?? 0);
        continue;
      }
      if (a && this.compareAttributes(a.attributes, r.attributes)) {
        a.text += r.text;
        continue;
      }
      i.push(r);
    }
    return i.length === 0 && i.push({
      text: "",
      attributes: {}
    }), z(ct, ft).set(t, i);
  }
  compareAttributes(t, e) {
    return P(t, e) && P(e, t);
  }
};
const R = D("children"), ct = D("content"), ft = D("spans");
class ut {
  constructor() {
    v(this, "blockEditor", new dt());
  }
  applyAction(t, e) {
    return this.blockEditor.applyAction(new $(t, []), e);
  }
  applyRangeAction(t, e, i) {
    const o = this.selectionToEditorRange(t, i);
    return this.blockEditor.applyAction(new $(t, o), e);
  }
  selectionToEditorRange(t, e) {
    let i = e;
    if (!i) {
      const s = window.getSelection();
      i = s == null ? void 0 : s.getRangeAt(0);
    }
    let o = [];
    if (!i)
      console.warn("No range found for action");
    else {
      const s = this.getShallowEditorRange(i);
      o = this.blockEditor.expandRange(t, s);
    }
    return o;
  }
  updateWindowSelection(t) {
    const e = this.editorRangeToSelection(t);
    if (e) {
      const i = window.getSelection();
      i == null || i.removeAllRanges(), i == null || i.addRange(e);
    }
  }
  editorRangeToSelection(t) {
    const e = new Range(), i = t.at(0), o = t.at(-1);
    if (!i || !o)
      return e;
    if (i.type === "title" && o.type === "title") {
      const s = document.querySelector('[data-element="title"]');
      if (s) {
        const r = this.findTextChild(s);
        r && (e.setStart(r, i.startOffset), e.setEnd(r, o.endOffset ?? 0));
      }
      return e;
    }
    if (i.type === "plain_text" && o.type === "plain_text") {
      const s = document.querySelector(`[data-block-id="${i.blockId}"]`), r = s == null ? void 0 : s.querySelector(`[data-editing-property="${i.property}"]`);
      if (r) {
        const a = this.findTextChild(r);
        a && (e.setStart(a, i.startOffset), e.setEnd(a, o.endOffset ?? i.startOffset));
      }
      return e;
    }
    if (i.type === "rich_text" && o.type === "rich_text") {
      const s = this.findSpanTextNode(i.blockId, i.spanIndex);
      s && e.setStart(s, i.startOffset);
      const r = this.findSpanTextNode(o.blockId, o.spanIndex);
      r && e.setEnd(r, o.endOffset ?? o.startOffset);
    }
    return e;
  }
  getShallowEditorRange(t) {
    var a, l, f, c;
    let e = null, i = 0, o = null, s, r;
    if (this.normalizeRange(t), t.startContainer instanceof Text)
      e = this.getElementAtNode(t.startContainer), i = t.startOffset;
    else if (t.startContainer instanceof Element)
      if (t.startOffset > t.startContainer.children.length) {
        if (e = this.getLastChildElement(t.startContainer), (e == null ? void 0 : e.type) === "span") {
          const d = this.getSpanTextContent(e.blockId, e.index);
          i = (d == null ? void 0 : d.length) ?? 0, r = i;
        }
      } else
        e = this.getElementAtNode(t.startContainer), i = ((a = t.startContainer.textContent) == null ? void 0 : a.length) ?? 0;
    if (t.endContainer instanceof Text)
      o = this.getElementAtNode(t.endContainer);
    else if (t.endContainer instanceof Element) {
      if (t.endOffset === 0)
        o = this.getFirstChildElement(t.endContainer);
      else if (o = this.getLastChildElement(t.endContainer), (o == null ? void 0 : o.type) === "span") {
        const d = this.getSpanTextContent(o.blockId, o.index);
        s = (d == null ? void 0 : d.length) ?? 0;
      }
      o === null && (o = this.getElementAtNode(t.endContainer), s = ((l = t.endContainer.textContent) == null ? void 0 : l.length) ?? 0);
    }
    if ((e == null ? void 0 : e.type) === "block")
      return [
        {
          type: "rich_text",
          blockId: e.blockId,
          spanIndex: 0,
          startOffset: i,
          endOffset: t.endOffset
        }
      ];
    if ((e == null ? void 0 : e.type) === "plain")
      return [
        {
          type: "plain_text",
          blockId: e.blockId,
          property: e.property,
          startOffset: i,
          endOffset: t.endOffset
        }
      ];
    if ((e == null ? void 0 : e.type) !== "span" || (o == null ? void 0 : o.type) !== "span") {
      let d;
      return (e == null ? void 0 : e.type) === "title" && o === null ? d = ((f = t.startContainer.textContent) == null ? void 0 : f.length) ?? 0 : d = Math.max(t.startOffset, t.endOffset), [
        {
          type: "title",
          startOffset: t.startOffset,
          endOffset: d
        }
      ];
    }
    return !e || !o ? [] : e.blockId === o.blockId && e.index === o.index ? [
      {
        type: "rich_text",
        blockId: e.blockId,
        spanIndex: e.index,
        startOffset: i,
        endOffset: s ?? t.endOffset
      }
    ] : [
      {
        type: "rich_text",
        blockId: e.blockId,
        spanIndex: e.index,
        startOffset: i,
        endOffset: r ?? ((c = t.startContainer.textContent) == null ? void 0 : c.length)
      },
      {
        type: "rich_text",
        blockId: o.blockId,
        spanIndex: o.index,
        startOffset: 0,
        endOffset: s ?? t.endOffset
      }
    ];
  }
  normalizeRange(t) {
    const e = (o) => {
      var s, r;
      if (o.startContainer.nodeType !== Node.TEXT_NODE) {
        let a = null, l = 0;
        o.startOffset === o.startContainer.childNodes.length ? (a = o.startContainer.lastChild, l = ((s = a == null ? void 0 : a.textContent) == null ? void 0 : s.length) ?? 0) : a = o.startContainer.childNodes.item(o.startOffset), (a == null ? void 0 : a.nodeType) === Node.TEXT_NODE ? (o.setStart(a, l), console.log("Set range start to child node")) : console.log("Failed to set range start to child node");
      }
      if (o.endContainer.nodeType !== Node.TEXT_NODE) {
        let a = null, l = 0;
        o.endOffset === o.endContainer.childNodes.length ? (a = o.endContainer.lastChild, l = ((r = a == null ? void 0 : a.textContent) == null ? void 0 : r.length) ?? 0) : a = o.endContainer.childNodes.item(o.endOffset), (a == null ? void 0 : a.nodeType) === Node.TEXT_NODE ? (o.setEnd(a, l), console.log("Set range end to child node")) : console.log("Failed to set range end to child node");
      }
    }, i = (o) => {
      if (o.startContainer.nodeType === Node.TEXT_NODE && o.startContainer.textContent === "" && o.startOffset === 0) {
        const s = o.startContainer.previousSibling;
        if (s)
          o.setStart(s, s.childNodes.length), console.log("Set range start to previous sibling");
        else {
          const r = o.startContainer.nextSibling;
          r && (o.setStart(r, 0), console.log("Set range start to next sibling"));
        }
      }
      if (o.endContainer.nodeType === Node.TEXT_NODE && o.endContainer.textContent === "" && o.endOffset === 0) {
        const s = o.endContainer.previousSibling;
        if (s)
          o.setEnd(s, s.childNodes.length), console.log("Set range end to previous sibling");
        else {
          const r = o.endContainer.nextSibling;
          r && (o.setEnd(r, 0), console.log("Set range end to next sibling"));
        }
      }
    };
    return e(t), i(t), e(t), t;
  }
  findChildAttribute(t, e) {
    if (t instanceof Element && t.hasAttribute(e))
      return t.getAttribute(e);
    for (const i of t.childNodes) {
      if (i instanceof Element && i.hasAttribute(e))
        return i.getAttribute(e);
      const o = this.findChildAttribute(i, e);
      if (o)
        return o;
    }
    return null;
  }
  findAttribute(t, e) {
    return t instanceof Element && t.hasAttribute(e) ? t.getAttribute(e) : t.parentElement ? this.findAttribute(t.parentElement, e) : null;
  }
  findTextChild(t) {
    return t instanceof Text ? t : t.firstChild ? this.findTextChild(t.firstChild) : t;
  }
  findSpanTextNode(t, e) {
    var o;
    const i = (o = document.querySelector(`[data-block-id="${t}"]`)) == null ? void 0 : o.querySelector(`[data-span-index="${e}"]`);
    return i ? this.findTextChild(i) : null;
  }
  getSpanTextContent(t, e) {
    var s;
    const i = (s = document.querySelector(`[data-block-id="${t}"]`)) == null ? void 0 : s.querySelector(`[data-span-index="${e}"]`);
    if (!i)
      return null;
    const o = this.findTextChild(i);
    return o ? o.textContent : null;
  }
  getFirstChildElement(t) {
    for (let e = 0; e < t.childNodes.length; e++) {
      const i = t.childNodes[e];
      if (this.isSpanNode(i)) {
        const o = this.getElementAtNode(i);
        if (o)
          return o;
      } else if (i instanceof Element) {
        const o = this.getFirstChildElement(i);
        if (o)
          return o;
      }
    }
    return null;
  }
  getLastChildElement(t) {
    for (let e = t.childNodes.length - 1; e >= 0; e--) {
      const i = t.childNodes[e];
      if (this.isSpanNode(i)) {
        const o = this.getElementAtNode(i);
        if (o)
          return o;
      } else if (i instanceof Element) {
        const o = this.getLastChildElement(i);
        if (o)
          return o;
      }
    }
    return null;
  }
  isSpanNode(t) {
    return t instanceof Element ? t.hasAttribute("data-span-index") : !1;
  }
  getElementAtNode(t) {
    const e = this.findAttribute(t, "data-span-index"), i = this.findAttribute(t, "data-editing-type"), o = this.findAttribute(t, "data-editing-property"), s = this.findAttribute(t, "data-block-id");
    return e && s ? {
      blockId: s,
      type: "span",
      index: Number.parseInt(e)
    } : i === "plain" && o && s ? {
      type: "plain",
      blockId: s,
      property: o
    } : s ? {
      type: "block",
      blockId: s
    } : this.findAttribute(t, "data-element") === "title" ? {
      type: "title"
    } : null;
  }
}
const j = {
  ArrowUp: "ArrowUp",
  ArrowDown: "ArrowDown"
}, pt = C({
  setup() {
    const n = F("config");
    return {
      dragging: B(!1),
      fileUpload: !!(n != null && n.features.fileUpload)
    };
  },
  methods: {
    handleDragEnter(n) {
      n.preventDefault(), this.dragging = !0;
    },
    handleDragOver(n) {
      n.preventDefault();
    },
    handleDragLeave(n) {
      this.dragging = !1;
    },
    handleDrop(n) {
      if (n.preventDefault(), this.dragging = !1, !n.dataTransfer)
        return;
      const t = n.dataTransfer.getData(J.BlockId);
      t != null && t.length && this.$emit("move", t), this.fileUpload && (n.dataTransfer.items ? [...n.dataTransfer.items].forEach((e, i) => {
        if (e.kind === "file") {
          const o = e.getAsFile();
          o && this.$emit("file", o);
        }
      }) : [...n.dataTransfer.files].forEach((e, i) => {
        this.$emit("file", e);
      }));
    }
  }
});
function ht(n, t, e, i, o, s) {
  return m(), w("div", {
    class: H({ dragging: n.dragging }),
    "data-element": "insertion-target",
    contenteditable: "false"
  }, [
    y("div", {
      onDragenter: t[0] || (t[0] = (...r) => n.handleDragEnter && n.handleDragEnter(...r)),
      onDragover: t[1] || (t[1] = (...r) => n.handleDragOver && n.handleDragOver(...r)),
      onDragleave: t[2] || (t[2] = (...r) => n.handleDragLeave && n.handleDragLeave(...r)),
      onDrop: t[3] || (t[3] = (...r) => n.handleDrop && n.handleDrop(...r))
    }, null, 32)
  ], 2);
}
const mt = /* @__PURE__ */ O(pt, [["render", ht], ["__scopeId", "data-v-a7f76d2b"]]), gt = C({
  props: {
    block: {
      type: Object,
      required: !0
    },
    placeholder: {
      type: String,
      required: !1
    },
    autofocus: {
      type: Boolean,
      required: !1,
      default: !1
    }
  }
}), yt = ["autofocus", "data-block-id", "data-block-type", "data-placeholder"], bt = { "data-editing-mode": "plain" };
function kt(n, t, e, i, o, s) {
  return m(), w("div", {
    "data-element": "block",
    autofocus: n.autofocus,
    "data-block-id": n.block.id,
    "data-block-type": n.block.type,
    "data-placeholder": n.placeholder
  }, [
    y("span", bt, E(n.block.content.text), 1)
  ], 8, yt);
}
const xt = /* @__PURE__ */ O(gt, [["render", kt], ["__scopeId", "data-v-75aca143"]]), wt = C({
  emits: ["formatBold", "formatItalic", "formatUnderline"]
}), It = {
  id: "floating-bar",
  contenteditable: "false"
};
function St(n, t, e, i, o, s) {
  return m(), w("div", It, [
    y("button", {
      onClick: t[0] || (t[0] = (r) => n.$emit("formatBold")),
      style: { "font-weight": "bold" }
    }, "F"),
    y("button", {
      onClick: t[1] || (t[1] = (r) => n.$emit("formatItalic")),
      style: { "font-style": "italic" }
    }, "K"),
    y("button", {
      onClick: t[2] || (t[2] = (r) => n.$emit("formatUnderline")),
      style: { "text-decoration": "underline" }
    }, "U")
  ]);
}
const Tt = /* @__PURE__ */ O(wt, [["render", St], ["__scopeId", "data-v-189ffbff"]]), Ot = {}, Ct = {
  xmlns: "http://www.w3.org/2000/svg",
  height: "24px",
  viewBox: "0 -960 960 960",
  width: "24px",
  fill: "currentColor"
};
function vt(n, t) {
  return m(), w("svg", Ct, t[0] || (t[0] = [
    y("path", { d: "m424-296 282-282-56-56-226 226-114-114-56 56 170 170Zm56 216q-83 0-156-31.5T197-197q-54-54-85.5-127T80-480q0-83 31.5-156T197-763q54-54 127-85.5T480-880q83 0 156 31.5T763-763q54 54 85.5 127T880-480q0 83-31.5 156T763-197q-54 54-127 85.5T480-80Zm0-80q134 0 227-93t93-227q0-134-93-227t-227-93q-134 0-227 93t-93 227q0 134 93 227t227 93Zm0-320Z" }, null, -1)
  ]));
}
const Bt = /* @__PURE__ */ O(Ot, [["render", vt]]), _t = C({
  props: {
    status: {
      type: String,
      required: !0
    },
    document: {
      type: Object,
      required: !0
    }
  },
  computed: {
    wordStatus() {
      return this.wordCount > 1 ? `${this.wordCount} Wörter` : this.wordCount === 1 ? "1 Wort" : "0 Wörter";
    },
    wordCount() {
      let n = 0;
      for (const t of this.document.children)
        "text" in t.content && (n += t.content.text.split(/\s+/).filter((e) => e.length > 0).length);
      return n;
    },
    characterStatus() {
      return `${this.characterCount} Zeichen`;
    },
    characterCount() {
      let n = 0;
      for (const t of this.document.children)
        "text" in t.content && (n += t.content.text.length);
      return n;
    }
  },
  components: {
    CheckCircleIcon: Bt,
    LoadingSpinnerIcon: Y
  }
}), Et = { key: 0 }, $t = { key: 1 };
function At(n, t, e, i, o, s) {
  const r = k("CheckCircleIcon"), a = k("LoadingSpinnerIcon");
  return m(), w("div", null, [
    y("p", null, E(n.characterStatus) + ", " + E(n.wordStatus), 1),
    n.status === "saved" ? (m(), w("p", Et, [
      T(r),
      t[0] || (t[0] = U(" Gespeichert "))
    ])) : n.status === "saving" ? (m(), w("p", $t, [
      T(a),
      t[1] || (t[1] = U(" Wird gespeichert "))
    ])) : G("", !0)
  ]);
}
const Rt = /* @__PURE__ */ O(_t, [["render", At], ["__scopeId", "data-v-da3db461"]]), Ft = C({
  props: {
    block: {
      type: Object,
      required: !0
    }
  }
}), Dt = ["data-block-id", "data-block-type"];
function Ut(n, t, e, i, o, s) {
  return m(), w("div", {
    "data-element": "block",
    "data-block-id": n.block.id,
    "data-block-type": n.block.type
  }, [
    y("code", null, E(n.block.content), 1)
  ], 8, Dt);
}
const Nt = /* @__PURE__ */ O(Ft, [["render", Ut]]), b = new ut(), qt = C({
  setup(n) {
    const t = F("config");
    if (!t)
      throw new Error("Missing dependencies");
    if (t.features.fileUpload && !t.callbacks.onUpload)
      throw new Error("Missing onUpload callback");
    if (t.features.fileUpload && !t.callbacks.getFileSourceUrl)
      throw new Error("Missing getFileSourceUrl callback");
    const e = F("data");
    console.log("Document:", e);
    const i = B(e), o = B(!1), s = B("idle"), r = W(async () => {
      s.value = "saving", await K(async () => {
        await t.callbacks.onSave(i.value);
      }, 1e3), o.value = !1, s.value = "saved";
    }, 1500);
    return {
      dirty: o,
      status: s,
      autoSave: r,
      document: i,
      onSave: t.callbacks.onSave,
      onExit: t.callbacks.onExit,
      onUpload: t.callbacks.onUpload,
      getFileSourceUrl: t.callbacks.getFileSourceUrl,
      files: B({})
    };
  },
  computed: {
    placeholder() {
      return this.isEmptyDocument ? "Beginne zu schreiben.." : void 0;
    },
    isEmptyDocument() {
      if (this.document.children.length > 1)
        return !1;
      for (const n of this.document.children)
        if ("text" in n.content && n.content.text.trim().length)
          return !1;
      return !0;
    }
  },
  mounted() {
    const n = this.document.children.at(-1);
    if ((n == null ? void 0 : n.type) === "rich-text") {
      const e = n.content.spans.at(-1);
      e && b.updateWindowSelection([
        {
          blockId: n.id,
          type: "rich_text",
          spanIndex: n.content.spans.length - 1,
          startOffset: e.text.length,
          endOffset: e.text.length
        }
      ]);
    }
    const t = W(this.handleSelectionChange, 150);
    document.addEventListener("selectionchange", t), window.addEventListener("beforeunload", (e) => {
      if (this.dirty)
        return e.preventDefault(), e.returnValue = "You have unsaved changes. Are you sure you want to leave?", e.returnValue;
    });
  },
  methods: {
    handleBeforeInput(n) {
      n.preventDefault();
      const t = window.getSelection(), e = t == null ? void 0 : t.getRangeAt(0);
      if (!e) {
        h.warn("Received beforeinput event without range", { type: n.inputType });
        return;
      }
      const i = this.getPlainInputData(n);
      switch (n.inputType) {
        case "insertText":
          return i ? this.handleInsertText(e, i) : void 0;
        case "insertLineBreak":
        case "insertParagraph":
          return this.handleInsertParagraph(e);
        case "insertFromPaste":
          return i ? this.handlePaste(e, i) : void 0;
        case "formatBold":
          return this.handleFormatBold(e);
        case "formatItalic":
          return this.handleFormatItalic(e);
        case "formatUnderline":
          return this.handleFormatUnderline(e);
        case "deleteContentBackward":
        case "deleteByCut":
          return this.handleDeleteContentBackward(e);
        case "insertReplacementText":
          return i ? this.handleInsertText(e, i) : void 0;
        default:
          h.warn("Unhandled beforeinput event", { type: n.inputType });
      }
    },
    handleSelectionChange() {
      const n = window.getSelection();
      if (!n) {
        h.warn("Selection is null");
        return;
      }
      const t = document.getElementById("floating-bar");
      if (!t)
        return;
      const e = n.getRangeAt(0);
      if (!b.selectionToEditorRange(this.document, e).find((r) => r.type === "rich_text") || e.collapsed) {
        t.style.display = "none";
        return;
      }
      t.style.display = "flex";
      const s = e.getBoundingClientRect();
      t.style.top = `${s.top + window.scrollY - t.offsetHeight - 10}px`, t.style.left = `${s.left + window.scrollX - 10}px`;
    },
    getPlainInputData(n) {
      var t;
      return n.data ? n.data : (t = n.dataTransfer) == null ? void 0 : t.getData("text/plain");
    },
    handleFormatBold(n) {
      const t = b.applyRangeAction(
        this.document,
        {
          type: "toggle_attribute",
          name: "bold"
        },
        n
      );
      this.updateEditorState(t);
    },
    handleFormatItalic(n) {
      const t = b.applyRangeAction(
        this.document,
        {
          type: "toggle_attribute",
          name: "italic"
        },
        n
      );
      this.updateEditorState(t);
    },
    handleFormatUnderline(n) {
      const t = b.applyRangeAction(
        this.document,
        {
          type: "toggle_attribute",
          name: "underline"
        },
        n
      );
      this.updateEditorState(t);
    },
    handleDeleteContentBackward(n) {
      const t = b.applyRangeAction(
        this.document,
        {
          type: "delete_text"
        },
        n
      );
      this.updateEditorState(t);
    },
    handleInsertText(n, t) {
      const e = b.applyRangeAction(
        this.document,
        {
          type: "insert_text",
          text: t
        },
        n
      );
      this.updateEditorState(e);
    },
    handleInsertParagraph(n) {
      const t = b.applyRangeAction(
        this.document,
        {
          type: "insert_paragraph"
        },
        n
      );
      this.updateEditorState(t);
    },
    insertBlock(n, t) {
      const e = t ?? this.document.children.length;
      this.document.children.splice(e, 0, n), this.dirty = !0, this.$nextTick(() => {
        this.autoSave();
      });
    },
    handlePaste(n, t) {
      const e = b.applyRangeAction(
        this.document,
        {
          type: "insert_text",
          text: t
        },
        n
      );
      this.updateEditorState(e);
    },
    updateEditorState(n) {
      this.document = n.document, this.dirty = !0, this.$nextTick(() => {
        b.updateWindowSelection(n.selection), this.autoSave();
      });
    },
    handleMove(n, t) {
      const e = b.applyAction(this.document, {
        id: n,
        index: t,
        type: "move_block"
      });
      this.updateEditorState(e);
    },
    handleFileDrop(n, t) {
      this.addFile(n, t);
    },
    handleRemoveBlock(n) {
      const t = b.applyAction(this.document, {
        id: n,
        type: "remove_block"
      });
      this.updateEditorState(t);
    },
    handleKeydown(n) {
      const t = n.shiftKey || n.altKey || n.metaKey || n.ctrlKey, e = n.ctrlKey || n.metaKey;
      switch (n.key) {
        case "a":
          if (e)
            return n.preventDefault(), this.handleSelectAll();
          break;
        case j.ArrowUp:
          return t ? void 0 : (n.preventDefault(), this.handleArrowUpKey());
        case j.ArrowDown:
          return t ? void 0 : (n.preventDefault(), this.handleArrowDownKey());
      }
    },
    handleArrowUpKey() {
      h.debug("Arrow Up key pressed");
    },
    handleArrowDownKey() {
      h.debug("Arrow Down key pressed");
    },
    handleArrowLeftKey() {
      h.debug("Arrow Left key pressed");
    },
    handleArrowRightKey() {
      h.debug("Arrow Right key pressed");
    },
    handleSelectAll() {
      h.debug("Select All pressed");
    },
    async handleSave() {
      await this.onSave(this.document), this.dirty = !1, this.onExit();
    },
    handleAddFile(n) {
      if (n.target instanceof HTMLInputElement && n.target.files)
        for (let t = 0; t < n.target.files.length; t++) {
          const e = n.target.files.item(t);
          if (!e)
            return;
          this.addFile(e);
        }
    },
    addFile(n, t) {
      const e = this.getFileType(n);
      if (!e) {
        h.warn("Unsupported file type", { file: n });
        return;
      }
      const i = crypto.randomUUID();
      this.files[i] = {
        state: "pending",
        type: e,
        source: n
      };
      const o = {
        id: crypto.randomUUID(),
        type: "file-ref",
        content: {
          id: i,
          name: n.name.split(".").at(0) ?? n.name,
          type: n.type
        },
        children: []
      };
      this.insertBlock(o, t), this.uploadFile(i);
    },
    getFileType(n) {
      if (n.type.startsWith("audio/"))
        return "audio";
      if (n.type.startsWith("image/"))
        return "image";
    },
    async uploadFile(n) {
      const t = this.files[n];
      if (!t) {
        h.warn("File not found", { id: n });
        return;
      }
      const e = await K(async () => {
        var i;
        return (i = this.onUpload) == null ? void 0 : i.call(this, t.source, this.document.id, n);
      }, 1e3);
      e && this.files[n] && (this.files[n].state = e);
    }
  },
  components: {
    StatusBar: Rt,
    FileBlock: ot,
    TitleBlock: nt,
    RootWrapper: et,
    UnknownBlock: Nt,
    BlockWrapper: tt,
    RichTextBlock: Q,
    PlainTextBlock: xt,
    RichTextFloatingBar: Tt,
    BlockInsertionTarget: mt
  }
}), Lt = { contenteditable: "false" }, Kt = {
  class: "bottom",
  contenteditable: "false"
}, Wt = { contenteditable: "false" };
function Mt(n, t, e, i, o, s) {
  const r = k("TitleBlock"), a = k("BlockInsertionTarget"), l = k("RichTextBlock"), f = k("FileBlock"), c = k("UnknownBlock"), d = k("BlockWrapper"), x = k("StatusBar"), p = k("RichTextFloatingBar"), g = k("RootWrapper");
  return m(), _(g, null, {
    default: N(() => [
      y("div", {
        "data-element": "editor",
        contenteditable: "true",
        onBeforeinput: t[2] || (t[2] = (...u) => n.handleBeforeInput && n.handleBeforeInput(...u)),
        onKeydown: t[3] || (t[3] = (...u) => n.handleKeydown && n.handleKeydown(...u))
      }, [
        y("div", Lt, [
          q(n.$slots, "title", {
            onSave: n.handleSave,
            onAddFile: n.handleAddFile,
            onFormatBold: () => n.handleFormatBold(),
            onFormatItalic: () => n.handleFormatItalic(),
            onFormatUnderline: () => n.handleFormatUnderline()
          }, void 0, !0)
        ]),
        T(r, {
          title: n.document.content.title
        }, null, 8, ["title"]),
        (m(!0), w(L, null, it(n.document.children, (u, S) => (m(), w(L, null, [
          T(a, {
            onMove: (I) => n.handleMove(I, S),
            onFile: (I) => n.handleFileDrop(I, S)
          }, null, 8, ["onMove", "onFile"]),
          T(d, {
            "block-id": u.id
          }, {
            default: N(() => [
              u.type === "rich-text" ? (m(), _(l, {
                key: 0,
                block: u,
                placeholder: S === 0 ? n.placeholder : void 0
              }, null, 8, ["block", "placeholder"])) : u.type === "file-ref" ? (m(), _(f, {
                key: 1,
                block: u,
                file: n.files[u.content.id],
                source: n.getFileSourceUrl(u.content.id),
                onRemove: n.handleRemoveBlock
              }, null, 8, ["block", "file", "source", "onRemove"])) : (m(), _(c, {
                key: 2,
                block: u
              }, null, 8, ["block"]))
            ]),
            _: 2
          }, 1032, ["block-id"])
        ], 64))), 256)),
        T(a, {
          onMove: t[0] || (t[0] = (u) => n.handleMove(u, n.document.children.length)),
          onFile: t[1] || (t[1] = (u) => n.handleFileDrop(u, n.document.children.length))
        }),
        t[4] || (t[4] = y("hr", { style: { "margin-top": "5em" } }, null, -1)),
        y("div", Kt, [
          T(x, {
            document: n.document,
            status: n.status
          }, null, 8, ["document", "status"]),
          q(n.$slots, "bottom", { onSave: n.handleSave }, void 0, !0)
        ]),
        y("div", Wt, [
          T(p, {
            onFormatBold: n.handleFormatBold,
            onFormatItalic: n.handleFormatItalic,
            onFormatUnderline: n.handleFormatUnderline
          }, null, 8, ["onFormatBold", "onFormatItalic", "onFormatUnderline"])
        ])
      ], 32)
    ]),
    _: 3
  });
}
const Xt = /* @__PURE__ */ O(qt, [["render", Mt], ["__scopeId", "data-v-6d2a3dc2"]]);
export {
  Xt as BlockEditor
};
